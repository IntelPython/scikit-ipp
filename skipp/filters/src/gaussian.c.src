#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "gaussian.h"

#define EXIT_FUNC exitLine:                                  /* Label for Exit */
#define check_sts(st) if((st) != ippStsNoErr) goto exitLine 

/**begin repeat
*
* #type = 8u, 16u, 16s, 32f#
*/

int
GaussianFilterIpp@type@_C1(void * pSRC,
                           void * pDST,
                           int img_width,
                           int img_height,
                           int numChannels,
                           float sigma_,
                           int kernelSize,
                           int stepSize,
                           int ippBorderType, 
                           float ippBorderValue)
{
    IppStatus status = ippStsNoErr;
    Ipp@type@ * pSrc = NULL;                // Pointers to source
    Ipp@type@ * pDst = NULL;                // destination images
                   
    int srcStep = stepSize, dstStep = stepSize;          // Steps, in bytes, through the
                                                         //source/destination images
    IppiSize roiSize = { img_width, img_height };        // Size of source/destination ROI in pixels
    Ipp32f sigma = (Ipp32f)sigma_;
    Ipp8u *pBuffer = NULL;                 // Pointer to the work buffer
    IppFilterGaussianSpec* pSpec = NULL;   // context structure
    int iTmpBufSize = 0, iSpecSize = 0;    // Common work buffer size
    IppiBorderType borderType = ippBorderType;
    Ipp@type@ borderValue = (Ipp@type@) ippBorderValue; // <<<<<~~~~~change border value
    //// border values i
    pSrc = (Ipp@type@ *) pSRC;
    pDst = (Ipp@type@ *) pDST;
    check_sts( status = ippiFilterGaussianGetBufferSize(roiSize,
                                                        kernelSize,
                                                        ipp@type@,
                                                        numChannels,
                                                        &iSpecSize, 
                                                        &iTmpBufSize) );
    pSpec = (IppFilterGaussianSpec *)ippsMalloc_8u(iSpecSize);
    if(NULL == pSpec)
        check_sts( status = ippStsMemAllocErr);
    pBuffer = ippsMalloc_8u(iTmpBufSize);
    if(NULL == pBuffer)
        check_sts( status = ippStsMemAllocErr);
    check_sts( status = ippiFilterGaussianInit(roiSize,
                                               kernelSize,
                                               sigma,
                                               borderType,
                                               ipp@type@,
                                               numChannels,
                                               pSpec,
                                               pBuffer) );
    check_sts( status = ippiFilterGaussianBorder_@type@_C1R(pSrc,
                                                            srcStep,
                                                            pDst,
                                                            dstStep,
                                                            roiSize,
                                                            borderValue,
                                                            pSpec,
                                                            pBuffer));

EXIT_FUNC
    ippsFree(pBuffer);
    ippsFree(pSpec);
    return (int)status;
}

int
GaussianFilterIpp@type@_C3(void * pSRC,
                           void * pDST,
                           int img_width,
                           int img_height,
                           int numChannels,
                           float sigma_,
                           int kernelSize,
                           int stepSize,
                           int ippBorderType,
                           float ippBorderValue)
{
    IppStatus status = ippStsNoErr;
    Ipp@type@ * pSrc = NULL;                // Pointers to source
    Ipp@type@ * pDst = NULL;                // destination images
    int srcStep = stepSize, dstStep = stepSize;          //Steps, in bytes, through the 
                                                         // source/destination images 
    IppiSize roiSize = { img_width, img_height };  // Size of source/destination ROI in pixels 
    Ipp32f sigma = (Ipp32f)sigma_;
    Ipp8u *pBuffer = NULL;                 // Pointer to the work buffer
    IppFilterGaussianSpec* pSpec = NULL;   // context structure
    int iTmpBufSize = 0, iSpecSize = 0;    // Common work buffer size
    IppiBorderType borderType = ippBorderType;
    Ipp@type@ borderValue[] = {0, 0, 0};   // <<<<<~~~~~change border value
    pSrc = (Ipp@type@ *) pSRC;
    pDst = (Ipp@type@ *) pDST;
    check_sts( status = ippiFilterGaussianGetBufferSize(roiSize,
                                                        kernelSize,
                                                        ipp@type@,
                                                        numChannels,
                                                        &iSpecSize,
                                                        &iTmpBufSize) );
    pSpec = (IppFilterGaussianSpec *)ippsMalloc_8u(iSpecSize);
    if(NULL == pSpec)
        check_sts( status = ippStsMemAllocErr);
    pBuffer = ippsMalloc_8u(iTmpBufSize);
    if(NULL == pBuffer)
        check_sts( status = ippStsMemAllocErr);
    check_sts( status = ippiFilterGaussianInit(roiSize,
                                               kernelSize,
                                               sigma,
                                               borderType,
                                               ipp@type@,
                                               numChannels,
                                               pSpec,
                                               pBuffer) );
    check_sts( status = ippiFilterGaussianBorder_@type@_C3R(pSrc,
                                                            srcStep,
                                                            pDst,
                                                            dstStep,
                                                            roiSize,
                                                            borderValue,
                                                            pSpec,
                                                            pBuffer));

EXIT_FUNC
    ippsFree(pBuffer);
    ippsFree(pSpec);
    return (int)status;
}
/**end repeat**/

static funcHandler
gaussianFilterTable[] = { GaussianFilterIpp8u_C1,
                          GaussianFilterIpp16u_C1,
                          GaussianFilterIpp16s_C1,
                          GaussianFilterIpp32f_C1,
                          GaussianFilterIpp8u_C3,
                          GaussianFilterIpp16u_C3,
                          GaussianFilterIpp16s_C3,
                          GaussianFilterIpp32f_C3,
                        };

int  
GaussianFilter(int index,
               void * pSRC,
               void * pDST,
               int img_width,
               int img_height,
               int numChannels,
               float sigma_,
               int kernelSize,
               int stepSize,
               int ippBorderType,
               float ippBorderValue)
{
    IppStatus status = ippStsNoErr;
    status = gaussianFilterTable[index](pSRC,
                                        pDST,
                                        img_width,
                                        img_height,
                                        numChannels,
                                        sigma_,
                                        kernelSize,
                                        stepSize,
                                        ippBorderType,
                                        ippBorderValue);
    return (int)status;
}